## **函数调用**



**函数开始前**

```c++
    pushl   $3              # 第二个参数 b=3 压栈（后压）
    pushl   $2              # 第一个参数 a=2 压栈（先压）
    call    add             # 调用 add 此时还会存下一行的地址
```



**函数的开始**

```c++
pushl %ebp #保存旧的%ebp 在这个函数里面就只有esp在动了ebp就不动了
movl  %esp, %ebp #让esp=ebp
subl  $X, %esp #给局部变量分配x的空间
```

那么此时栈的结构就类似这种

```c++
高地址
...
参数 b        <-- 12(%ebp)
参数 a        <-- 8(%ebp)
返回地址      <-- 4(%ebp)
旧 ebp       <-- 0(%ebp) / (%ebp)
局部变量 c   <-- -4(%ebp)
...
低地址
```



此时比如

```c++
 movl -4(%ebp) %eax 就是让寄存器%eax=c
```



**函数的结束**

```c++
    leave                   # 9. 相当于 mov %ebp, %esp; pop %ebp
    ret                     # 10. 弹出返回地址到 eip，跳回调用者
```



**回到主程序**

```c++
addl    $8, %esp         回收压入的两个参数（2 个 * 4 字节）
#此时eax里面存的就是返回值
```



**return 0**

```c++
 8048b0d:	b8 00 00 00 00       	mov    $0x0,%eax
 8048b12:	eb 0f                	jmp    8048b23 <phase_2+0x94>
```



**push/pop**

```c++
pushl x esp-=4 [esp]=x
popl r:r=[esp] esp+=4
```

**call**

```c++
call func //把下一条指令压栈然后调用func
```



## 语法规则

- 寄存器带% `%eax,%ebx`

- 立即数带$ $0x10 表示常数16
- 内容用括号`()` 8(%ebp) 表示内存(%ebp+8)处的值
- 操作数顺序：源->目的
- 后缀表示宽度：b:8位，w=16位，l=32位，q=64位



#### mov 数据搬运

```c++
movl a,b //赋值符号b=a
movl -0x4(%ebp),%edx //把栈上局部变量读到edx
mov -0x24(%ebp,%edx,4),%ecx //ebp-0x24是数组a开始 ecx=a[edx];

movzbl //源操作数是地址或者8位寄存器 右边是32位寄存器并且高位补0
movzbl %al,%eax 
movzbl (%eax),%eax
movsbl //源操作数是地址或者8位寄存器 右边是32位寄存器并且按符号位拓展
movsbl %al,%eax
```



#### lea 

**不读内存内容 只做地址计算**

```c++
leal disp(base,index,scale),reg
=>reg=disp=base+index*scale
leal -0x24(%ebp), %eax //eax=ebp-0x24 此时eax存的是一个地址的值
leal (%eax,%eax,4) ,%edx //edx=eax+4*eax 
leal 12(%eax),%eax //eax=eax+12
```



#### test 按位与

**只设置标志位不保存结果**

```c++
test a,b  a&b
test %eax,%eax //检查eax是否为0
//后面如果接je 表示 if a==0
//后面如果接js 表示 if a<0
```



#### cmp比较

```c++
cmp a,b 计算b-a 但是不写回 只设置标志位
后面常接j**
```



#### j** 条件跳转

```c++
je jne //相等 不相等
jz  jnz //为0 不为0
//有符号比较 多半是int
jl < jle <= jg > jge >=
//无符号比较 多半是unsigned和地址比较
jb < jbe <= ja > jae >=
```



#### 算术类

```c++
addl a,b b+=a
subl a,b b-=a
imull 有符号乘法 常用imull %k,%eax
```



#### 位运算/移位

```c++
and/or/xor 会写回目的操作数，并改写符号位
xorl %eax,%eax //eax=0
shl //逻辑左移
shr //逻辑右移 高位补0
sar //算数右移 高位补符号位
sarl $31,%eax //取符号位
```


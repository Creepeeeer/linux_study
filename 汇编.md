## 1. 先认识“角色”：寄存器

常见的一共就这些（只记 64 位版本就行，都是 `%rxx`）：

- `%rax`：**返回值寄存器**，函数返回值放这里
- `%rbx`：一般用来当**普通临时变量**
- `%rcx`：临时寄存器
- `%rdx`：临时寄存器
- `%rsi`：函数第 2 个参数
- `%rdi`：函数第 1 个参数
- `%rbp`：**基址寄存器**（旧式写法当“栈帧指针”）
- `%rsp`：**栈顶指针**，栈从高地址往低地址长
- `%r8` ～ `%r15`：更多通用寄存器

另外同一个寄存器有不同“宽度”的名字，比如：

- `%rax`（64 位）
- `%eax`（低 32 位）
- `%ax`（低 16 位）
- `%al`（低 8 位）

bomb.s 里经常看到 `%eax`、`%edx` 这类，就是只操作低 32 位。

------

## 2. 函数是怎么调用的（调用约定）

在 bomb lab 里，每个 `phase_x` 都是一个函数，GCC 用的是 **System V x86-64 调用约定**。规则：

### 2.1 参数怎么传

**前 6 个参数** 用寄存器传：

1. 第 1 个参数：`%rdi`
2. 第 2 个参数：`%rsi`
3. 第 3 个参数：`%rdx`
4. 第 4 个参数：`%rcx`
5. 第 5 个参数：`%r8`
6. 第 6 个参数：`%r9`

比如 C 里：

```
int f(int a, long b, long c);
```

汇编里进 `f` 的时候就是：

- `a` 在 `%edi`（32 位低部分）
- `b` 在 `%rsi`
- `c` 在 `%rdx`

**字符串参数**（比如 `char *s`）传的是“指针”，也是在这些寄存器里，只不过那个指针指向一段内存。

### 2.2 返回值怎么传

- 返回值放在 `%rax`（或者低 32 位 `%eax`）里。

比如：

```
mov $0, %eax   # 返回 0
ret
```

------

## 3. 栈和栈帧：`%rbp`、`%rsp` 出场

函数开始和结束一般有一套“固定模板”（**函数序言 + 结束语**）。

典型函数长这样：

```
foo:
    push   %rbp          # 保存旧的 rbp
    mov    %rsp, %rbp    # 建立新的栈帧
    sub    $0x20, %rsp   # 给局部变量留 0x20 字节空间

    ...  # 函数主体

    leave                # = mov %rbp, %rsp; pop %rbp
    ret
```

含义：

- `push %rbp`
   栈顶往下长 8 字节，把旧 `%rbp` 压栈保存。
- `mov %rsp, %rbp`
   让 `%rbp` 指向当前栈顶，这一层函数的“栈帧起点”。
- `sub $0x20, %rsp`
   栈顶再往下挪 0x20 字节，给局部变量腾空间。

这样：

- **局部变量** 通常用 `-0x8(%rbp)`、`-0x10(%rbp)` 这样的地址访问。
- **栈上的参数**（超过 6 个时）会是 `0x10(%rbp)`、`0x18(%rbp)` 这样。

bomb.s 里每个 `phase_x` 基本都是这个套路开头 / 结尾。

------

## 4. 最常见的指令：只要看懂这些就能拆弹

### 4.1 数据搬运：`mov`

```
mov src, dst
```

几种典型：

```
mov %rax, %rbx      # 寄存器 -> 寄存器
mov $10, %eax       # 立即数 10 -> %eax
mov -0x8(%rbp), %rax # 内存[rbp-8] -> %rax
mov %eax, -0x8(%rbp) # %eax -> 内存[rbp-8]
```

前面多了后缀的意思：

- `movq`：操作 8 字节（64 位）
- `movl`：操作 4 字节（32 位）
- `movb`：操作 1 字节（8 位）

现代 GCC 很喜欢用 `mov` + 寄存器名字本身的宽度来区分。

------

### 4.2 算术：`add` / `sub` / `imul`

```
add src, dst   # dst = dst + src
sub src, dst   # dst = dst - src
imul src, dst  # dst = dst * src（有多种形式，bomb 里用的简单形式）
```

例子：

```
add $1, %eax        # eax++
sub $4, %rsp        # 栈顶向下挪 4 字节
imul %ecx, %eax     # eax *= ecx
```

------

### 4.3 逻辑 & 测试：`and` / `or` / `xor` / `test`

`test` **不会改变操作数，只设置标志位**。常见写法：

```
test %eax, %eax     # 等价于  cmp $0, %eax
je   some_label     # 如果 eax == 0 跳转
jne  other_label    # 如果 eax != 0 跳转
```

bomb 里经常看到：

```
test %eax, %eax
jne  explode_bomb
```

翻译成 C 就是：

```
if (eax != 0) explode_bomb();
```

或者反过来，取决于设计。

------

### 4.4 比较 + 条件跳转：`cmp` + `jxx`

```
cmp src, dst   # 实际干的是 dst - src，更新标志位，不存结果
```

然后配合各种跳转：

- `je label`：equal，==
- `jne label`：not equal，!=
- `jg label`：greater，>（有符号）
- `jge label`：>=
- `jl label`：<
- `jle label`：<=
- `ja` / `jb`：无符号比较的 > / <（above / below）

例子：

```
cmp $10, %eax   # 相当于 if (eax ? 10)
jg  bigger      # 如果 eax > 10 跳到 bigger
```

------

### 4.5 无条件跳转：`jmp`

```
jmp label   # 直接跳过去
```

常见于循环或 if/else 的结构。

------

### 4.6 函数调用：`call` / `ret`

```
call func
```

- 把“下一条指令地址”压入栈
- 跳到 `func` 执行

`func` 结束时：

```
ret
```

- 从栈顶弹出返回地址
- 跳回去继续执行

配合参数/返回值你就能知道 C 里函数怎么传东西。

------

### 4.7 地址计算：`lea`

`lea` = **Load Effective Address**，只做地址计算，不访问内存。

```
lea 0x8(%rbp), %rax    # rax = rbp + 0x8
lea (%rdi,%rsi,4), %rax # rax = rdi + rsi*4
```

bomb 里经常拿来算数组下标、偏移，不是真的“加载内存内容”。

------

## 5. 地址模式：看懂 `xxx(%reg1,%reg2,scale)`

通用形式：

```
disp(base, index, scale)
= base + index * scale + disp
```

例子：

- `-0x8(%rbp)`
   = `%rbp + (-0x8)`，通常某个局部变量
- `8(%rdi,%rcx,4)`
   = `%rdi + %rcx * 4 + 8`，典型的 `arr[rcx]` 一类

如果只有一个括号：

- `(%rax)`：就是 `[rax]` 这个地址里的内容

------

## 6. 结合 bomb 里的 `phase_1` 看一眼模式（不泄题）

一个典型（虚构但结构一样）的 `phase_1` 长这样：

```
phase_1:
    push   %rbp
    mov    %rsp, %rbp

    sub    $0x20, %rsp      # 给局部变量留空间

    mov    %rdi, -0x8(%rbp) # 把传进来的字符串指针保存到局部变量

    mov    -0x8(%rbp), %rdi # 取出这个字符串，放到第 1 个参数寄存器
    lea    some_str(%rip), %rsi # 第 2 个参数：正确答案的字符串地址
    call   strings_not_equal     # 比较这两个字符串

    test   %eax, %eax        # 看返回值是不是 0
    jne    explode_bomb      # !=0 说明不相等，炸弹爆炸

    leave
    ret
```

你需要看懂的关键点：

1. **`phase_1` 的参数**

   - 调用 `phase_1` 的地方，通常会写：`call phase_1` 前，把一个指针放到 `%rdi`
   - 这是用户输入的字符串（`read_line()` 的返回值）

2. `strings_not_equal` 函数：

   - 参数 1：输入字符串 `%rdi`
   - 参数 2：正确字符串 `%rsi`
   - 返回值：
     - `0`：相等
     - 非 0：不等

   所以 `test %eax, %eax; jne explode_bomb` 的意思就是
    **“如果不相等就爆炸”**。

3. `lea some_str(%rip), %rsi`

   - `some_str` 是一个全局字符串常量，类似 `". . .\0"` 的那种
   - 你的任务就是想办法找到这个正确字符串。

> 但是：**我不会直接把那串字符串给你**，那就变成我帮你作弊了（这属于作业答案）。
>  我会教你如何自己通过反汇编/调试找到它。

等你把上面这些汇编都大致看懂了，我们下一步就可以**专门拿 bomb 的 `phase_1` 来逐行读一遍**，教你怎么从 `bomb.s` 里看出“对比了什么字符串”、“怎么传的参数”，再用 gdb 配合看内存里那串正确答案长什么样。

------

## 7. 你现在可以做的小练习

为了不一下子信息太多，你可以先在脑子里过一下这几个问题（不会也没关系）：

1. 给你这段汇编你能说出它的大致逻辑吗？

   ```
   cmp $5, %eax
   jle L1
   mov $1, %eax
   jmp L2
   ```

L1:
 mov $0, %eax
 L2:
 ret

```
（提示：相当于一个 `if (x <= 5) ... else ...`）

2. 看下面这段：

```asm
mov -0x8(%rbp), %rax
mov (%rax), %edx
```

你能描述下第二行做了什么吗？（先解释 `(%rax)`）

------

如果你愿意，下一条消息我就直接带着你看一个**简化版 `phase_1`** 的完整反汇编，从 `call` 开始，到 `strings_not_equal` 返回，带你走一遍“如何从汇编还原出 C 逻辑”，但仍然不直接给 bomb 的最终答案。
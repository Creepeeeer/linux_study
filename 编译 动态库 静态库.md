### 编译

```c++
gcc/g++ 选项 源代码文件1，源代码文件2... 生成文件
```

#### 编译选项：

**-o :给输出文件起名字** ：后面加要生成文件的名字 如果没有-o就生成默认的名字



**-E/-S/-c :选择编译的阶段**：（大写）

-E：生成预处理文件.i  把 `#include` 展开、处理 `#define` 宏、删注释……

```c++
gcc -E main.c -o main.i
```

-S ：把 C 代码翻译成 **汇编代码**（文本形式）。（大写）

```c++
gcc -S main.c -o main.s
```

-c:汇编（小写）

把汇编代码变成 **目标文件（.o）**，是二进制，但还不能单独运行。

```
gcc -c main.c -o main.o
# 或者
gcc -c main.s -o main.o
```

**把多个.o和库链接在一起就能生成可执行文件**



**-Wall -Wextra**：打开常用警告，帮你发现很多坑

**`-std=c++17`**：指定 C++ 标准（C 用 `-std=c11` 之类）

**-g**：在可执行文件里加入调试信息，gdb 才能显示源码行号、变量名

**-O1/O2/O3(字母O):** 优化性能 优化程度 O3 >O2 >O1



### 静态库和动态库

**静态库的生成**

先将.cpp/.c文件编译成.o文件

```c++
g++ -c func.cpp -o func.o
g++ -c func2.cpp -o func2.o
```



然后编写静态库

```c++
ar rcs lib[自定义库名].a func.o func2.o....
#ar -r libfunc.a func.o
```



链接成可执行文件

```c++
g++ [名字].cpp -o [自定义可执行文件名]  -L[库的路径] -l[库名]
#g++ main.cpp -o main -L/home/creep/Desktop/1 -l func
```



**动态库的生成**

先将.cpp/.c文件编译成.o文件

```c++
g++ -fpic -c func.cpp -o func.o
g++ -fpic -c func2.cpp -o func2.o
```

`-fPIC` 做的事就是：**要求编译结果里多用“相对自己”的寻址方式**，而不是依赖绝对地址。这就叫 “Position-Independent Code”。

然后编写动态库

```c++
g++ -shared func.o func2.o ....-o lib[库名].so
#g++ -shared func.o -o libfunc.so
```



链接成可执行文件

```c++
g++ [名字].cpp -o [可执行文件名] -L[库的路径] -l[库名] -Wl，-rpath=[库的路径]
#g++ main.cpp -o main -L/home/creep/Desktop/1 -lfunc -Wl,-rpath=/home/creep/Desktop/1
```



**静态库和动态库的区别**

静态库会把.cpp/.c需要的.o文件直接拷贝出来，.cpp/.c已经有了所需要的机器码

动态库只是在.cpp/.c中记录一下哪里需要.so文件，运行的时候动态链接库才会去找

**如果改了库代码没改函数实现**，静态库需要重新需要重新生成-o，库lib[].a和可执行文件，动态库只需要重新生成-o,库lib[].so



